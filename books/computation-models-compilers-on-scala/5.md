---
title: 5 自作言語の仕様書
---
## 5 自作言語の仕様書

favaは静的型付け言語である。組込み型には、整数型と実数型と論理型と文字列型と関数型があり、型推論が行われる。
整数型は符号付き32 bit整数で、実数型はIEEE 754 (64 bit 2進数)浮動小数点数で、文字列はUTF-16で表現される。

|-|-|
|---|---|
|整数型 | `int  ::= [0-9]+` |
|実数型 | `real ::= [0-9]* ([0-9] '.' / '.' [0-9]) [0-9]*` |
|論理型 | `bool ::= 'true' / 'false'` |
|文字列 | `text ::= '"' [^"]* '"'` |
|関数型 | `func ::= '(' (id (',' id)*)? ')' '=>' expr`|

識別子は、その識別子が記述された箇所を包含し、識別子と同じ名前の引数を持つ、最も内側の関数の引数を参照する。
関数の内外で変数を宣言または代入する機能はなく、従って、識別子が参照する実体は何らかの関数の引数に限られる。

|-|-|
|---|---|
|識別子 | `id ::= [@A-Z_a-z] [@0-9A-Z_a-z]*`|

引数の値は変更不可能なため、識別子を含む式が参照する実体は、状態によらず自明である。これを**参照透明性**と呼ぶ。
複数の文を逐次的に実行する**ブロック構文**はなく、関数宣言の構文も省略した。以下に解析表現文法による定義を示す。

|-|-|
|---|---|
|ラムダ式 | `expr ::= cond / or` |
|条件分岐 | `cond ::= or  '?' expr ':' expr` |
|論理積   | `or   ::= or  '|' and / and` |
|論理和   | `and  ::= and '&' eql / eql` |
|等値比較 | `eql  ::= eql ('==' / '!=') rel / rel` |
|順序比較 | `rel  ::= rel ('<' / '>' / '<=' / '>=') add / add` |
|加減算   | `add  ::= add ('+' / '-') mul / mul`|
|乗除算   | `mul  ::= mul ('*' / '/' / '%') unr / unr` |
|単項演算 | `unr  ::= ('+' / '-' / '!') unr / call` |
|関数適用 | `call ::= call '(' expr (',' expr) ')' / fact` |
|式の要素 | `fact ::= func / bool / text / real / int / id / '(' expr ')'`|

この定義は左再帰を含む。中置記法の論理演算と比較演算と算術演算は、全て左結合である。単項演算は右結合である。
関数は、他の関数を引数や返り値にできる。これを**高階関数**と呼ぶ。ただし、関数は宣言できず、従って**無名関数**である。

```
fava$ ((function)=>function())(()=>1+2)
3
```

高階関数の内部で定義された関数からは、外側の高階関数で定義された引数を参照できる。この関数を**関数閉包**と呼ぶ。
関数の引数は、その引数を参照する関数閉包が存在し、参照される限り、関数適用が完了しても生存し、参照可能である。

```
fava$ ((x)=>((y)=>x*y))(2)(3)
6
```

引数の値は、関数を呼び出す時点では計算されず、値が必要になった時点で計算される。この動作を**非正格評価**と呼ぶ。
**遅延評価**とも呼ばれる。詳細は第3章に述べるが、端的に言えば、再帰的な関数が無限再帰に陥るのを防ぐ効果がある。

```
fava$ ((f)=>((x)=>f(x(x)))((x)=>f(x(x))))((f)=>(n)=>(n==0)?1:n*f(n-1))(10)
3628800
```

