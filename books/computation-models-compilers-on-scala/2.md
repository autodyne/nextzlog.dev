---
title: 2 計算モデルを作る
---
## 2 計算モデルを作る

**言語処理系**とは、言語仕様に沿って書かれた計算手順を読み取り、任意の計算機を構築または模倣する**万能機械**である。
計算機を抽象化した数学的な模型を**計算モデル**と呼ぶ。例えば、論理回路は第2.1節に述べる**有限状態機械**で表現できる。

### 2.1 有限状態機械

有限状態機械は、**状態**と**遷移規則**の有限集合で構成される。論理回路で言えば、**記憶素子**が保持する情報が状態である。
有限状態機械に信号 $x_n$ を与えると、Table 2.1の遷移規則に従って、状態 $q_n$ から状態 $q_{n+1}$ に遷移して、信号 $y_n$ を返す。

Table 2.1 state transition tables.

(1) SR flip-flop.

|$x_n$  |  $q_n$  |  $q_{n+1}$  |  $y_n$  |
|---|---|---|---|
|00 | 0 | 0 | 0 |
|00 | 1 | 1 | 1 |
|01 | 0 | 0 | 0 |
|01 | 1 | 0 | 1 |
|10 | 0 | 1 | 0 |
|10 | 1 | 1 | 1 |
|11 | 0 | - | - |
|11 | 1 | - | -|


(2) JK flip-flop.

|$x_n$  |  $q_n$  |  $q_{n+1}$  |  $y_n$  |
|---|---|---|---|
|00 | 0 | 0 | 0 |
|00 | 1 | 1 | 1 |
|01 | 0 | 0 | 0 |
|01 | 1 | 0 | 1 |
|10 | 0 | 1 | 0 |
|10 | 1 | 1 | 1 |
|11 | 0 | 1 | 0 |
|11 | 1 | 0 | 1|


(3) 2bit counter.

|$x_n$  |  $q_n$  |  $q_{n+1}$  |  $y_n$  |
|---|---|---|---|
|0 | 00 | 00 | 00 |
|1 | 00 | 01 | 00 |
|0 | 01 | 01 | 01 |
|1 | 01 | 10 | 01 |
|0 | 10 | 10 | 10 |
|1 | 10 | 11 | 10 |
|0 | 11 | 11 | 11 |
|1 | 11 | 00 | 11|

有限状態機械が受け取る信号列を**文**と見做す場合もある。これを言語処理に応用する体系が、第5章の**言語理論**である。
有限状態機械には、それに対応する**正規表現**が必ず存在する。この性質を利用して、正規表現の処理系を実装してみる。

```scala
class R[S](val test: Seq[S] => Option[Seq[S]])
```

正規表現は、正規表現を結合して、帰納的に定義できる。その最小単位が以下に示すOne型で、特定の1文字に適合する。

```scala
case class One[S](r: S) extends R[S](Some(_).filter(_.head == r).map(_.tail))
```

適合すると、残りの文字列を返す。ここに別の正規表現を適用すれば、正規表現の連結を意味する。これがCat型である。
Alt型は、正規表現の選択肢を表す。これは、遷移先の状態が複数ある状況を表す。これを遷移規則の**非決定性**と呼ぶ。

```scala
case class Cat[S](l: R[S], r: R[S]) extends R[S](seq => l.test(seq).map(r.test).flatten)
case class Alt[S](l: R[S], r: R[S]) extends R[S](seq => l.test(seq).orElse(r.test(seq)))
```

Opt型は、指定された正規表現の省略可能な出現を表す。また、Rep型は、指定された正規表現の0回以上の反復を表す。

```scala
case class Opt[S](r: R[S]) extends R[S](seq => r.test(seq).orElse(Some(seq)))
case class Rep[S](r: R[S]) extends R[S](seq => Cat(r, Opt(Rep(r))).test(seq))
```

正規表現Z(L+\|G)Oに相当する、有限状態機械の実装例を示す。第2.1節の内容を応用すれば、言語処理系も実装できる。

```scala
val ZLO = Cat(One('Z'), Cat(Alt(Rep(One('L')), One('G')), One('O')))
println(if(ZLO.test("ZLLLLLLLLLLLLLLLLO").isDefined) "OK" else "NO")
```

### 2.2 逆ポーランド記法

**スタック**を備え、再帰計算に対応した有限状態機械を**プッシュダウンオートマトン**と呼ぶ。式 2.1の遷移関数 $\delta$ に従う。
 $Q$ は状態の、 $\Sigma$ と $\Gamma$ は入力とスタックの記号の有限集合である。 $\Gamma^*$ は $\Gamma$ の元を並べた任意長の記号列 $y^*$ の集合である。

$$(q_{n+1},y^*_n) = \delta(q_n,\sigma_n,x_n),
\enspace\mathrm{where}\enspace
\left\lbrace 
\begin{aligned}
q_n &\in Q,\\
x_n &\in \Gamma,\\
y^*_n &\in \Gamma^*,\\
\sigma_n &\in \Sigma.
\end{aligned}
\right. \qquad(2.1)$$

記号 $\sigma_n$ を受け取ると、スタックの先頭の記号 $x_n$ を取り除き、先頭に記号列 $y^*_n$ を順番に積んで、状態 $q_{n+1}$ に遷移する。
再帰計算を活用した例として、第2.1節で実装した正規表現の拡張を考える。以下の関数ZLOは、記号列 $\texttt{Z}^n\texttt{L}\texttt{O}^n$ を表す。

```scala
def ZLO: R[Char] = Cat(One('Z'), Cat(Alt(One('L'), new R(ZLO.test(_))), One('O')))
println(ZLO.test("ZZZZZZZZZZZZZZZZZZZZZZZZZLOOOOOOOOOOOOOOOOOOOOOOOOO").isDefined)
```

残念ながら、単純な再帰計算は実行できても、受け取った記号列を読み返せる機能がなく、実行可能な計算は限られる。
ただし、記憶装置としてスタックを使う広義の**スタック機械**は、重要な計算モデルである。式 2.2の計算を例に考える。

$$(1 + 2) * (10 - 20). \qquad(2.2)$$

演算子には優先順位があるため、式を左から読むだけでは、計算は困難である。数値を保持する記憶装置も必要である。
前者は、式 2.3の**逆ポーランド記法**で解決する。演算子に優先順位はなく、出現する順番に、直前の数値に適用される。

$$\texttt{1 2 + 10 20 - *}. \qquad(2.3)$$

手順をFig. 2.1に示す。逆ポーランド記法は、式の読み返しを伴う再帰計算や条件分岐を除き、任意の計算を実行できる。
その再帰計算や条件分岐も、指定された長さだけ記号列を遡る**分岐命令**があれば実現できる。詳細は第7章に解説する。

![images/pola.anime.png](/images/pola.anime.png)

Fig. 2.1 1 2 + 10 20 - *.

以下に、四則演算を行う計算機の実装を示す。Stack型を継承し、Fig. 2.1に示した手順で、数式の値を逐次的に求める。
式は、空白で区切られた整数と演算子の列である。整数を読み取るとスタックに積み、演算子を読み取ると演算を行う。

```scala
object ArithStackMachine extends collection.mutable.Stack[Int]() {
  def apply(program: String): Int = program.split(" +").map {
    case "+" => push(((a: Int, b: Int) => b + a)(pop(), pop()))
    case "-" => push(((a: Int, b: Int) => b - a)(pop(), pop()))
    case "*" => push(((a: Int, b: Int) => b * a)(pop(), pop()))
    case "/" => push(((a: Int, b: Int) => b / a)(pop(), pop()))
    case num => this.push(num.toInt)
  }.lastOption.map(_ => pop()).last
}
```

この実装は、第5章で再び使用する。第5章では、中置記法の数式を逆ポーランド記法に変換するコンパイラを実装する。

```scala
println(ArithStackMachine("1 2 + 10 20 - *")) // -30
println(ArithStackMachine("3 4 * 10 20 * +")) // 212
println(ArithStackMachine("5 6 10 + 20 * +")) // 325
println(ArithStackMachine("7 8 10 * 20 - *")) // 420
```

