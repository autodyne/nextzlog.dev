---
title: 1 言語処理系を作る
---
## 1 言語処理系を作る

本書では、**ラムダ計算**を理論的背景に持つ独自のプログラミング言語の**インタプリタ**を自作して、**計算論**の基礎を学ぶ。
自作する言語の名前はfavaとする。最低限の機能に限定した簡素な言語だが、改良次第では高機能な言語に拡張できる。

### 1.1 サンプル

理念的には**純粋関数型言語**に分類できる。状態の概念がなく、式の値は定数だが、理論的には任意の計算を実行できる。
関数は他の関数の引数や返り値にできる。ただし、関数の名前も局所変数も定義できず、参照可能な変数は引数に限る。

```
fava$ ((x)=>(y)=>3*x+7*y)(2)(3)
27
```

実用的な計算が困難な程の制約に思えるが、実際には第4章で述べる通り、任意の計算を実行できる。階乗も計算できる。

```
fava$ ((f)=>((x)=>f(x(x)))((x)=>f(x(x))))((f)=>(n)=>(n==0)?1:n*f(n-1))(10)
3628800
```

自然数を関数で定義する例を示す。この例題は、関数型言語が任意の計算を実行できる性質を示す際に、よく登場する。

```
fava$ ((f,x)=>f(f(f(f(f(x))))))((x)=>x+1,0) // 0 + 1 + 1 + 1 + 1 + 1
5
```

任意の順序組も定義できる。端的に言えば構造体に相当し、複雑なグラフ構造も関数で表現できる性質を示す例である。

```
fava$ ((pair)=>pair((car,cdr)=>car))(((car,cdr)=>(z)=>z(car,cdr))(12,34))
12
fava$ ((pair)=>pair((car,cdr)=>cdr))(((car,cdr)=>(z)=>z(car,cdr))(12,34))
34
```

### 1.2 開発環境

favaの実装は公開済みで、以下の操作でビルドできる。実行環境としてJavaが、開発環境としてGradleが必要である。

```
$ git clone https://github.com/autodyne/fava
$ gradle build -p fava
```

以下の操作で起動する。fava以外にも、第2章で実装する様々な計算モデルを実験する機能も含まれ、起動時に選べる。
favaは対話的に実行できる。favaの内部で実行される命令列を表示する機能も用意した。内部的な動作の理解に使える。

```
$ java -jar build/libs/fava.jar --fava
fava$ "HELLO, WORLD!"
HELLO, WORLD!
fava$ compile(1 + 2)
Push(1) Push(2) IAdd
fava$ exit
$ java -jar build/libs/fava.jar --lisp
lisp$ (+ 1 2 3)
6
lisp$ (exit)
```

