---
title: 3 万能な計算モデル
---
## 3 万能な計算モデル

第3章では、記憶装置を備えた有限状態機械を解説する。再帰計算に対応し、可能な計算の範囲はラムダ計算に匹敵する。

### 3.1 セルオートマトン

**セル**と呼ばれる有限状態機械が縦横に並び、各々 $k$ 個の隣接セルの状態を参照して、式 3.1により同時に状態遷移する。

$$\delta: Q^k \to Q. \qquad(3.1)$$

空間に跨る記憶装置を得た恩恵で、再帰的な情報を表現できる。また、任意の計算機を模倣する遷移規則を設定できる。
例えば、Fig. 3.1の**ワイヤワールド**は、黄色のセルで配線すると、赤青の信号が配線を巡り、様々な論理回路を模倣する。

![images/wire.count.png](/images/wire.count.png)

(1) 4bit counter.
 
![images/wire.adder.png](/images/wire.adder.png)

(2) serial adder.

Fig. 3.1 wireworld logic circuits.

任意の論理回路を自由に配置でき、その様子を言語と捉えれば、Fig. 3.1は言語処理系と等価である。以下に実装を示す。

```scala
class CA2[S](rule: Seq[Seq[S]] => S, d: Int = 1) {
  def ROI[V](i: Int)(s: Seq[V]) = Range.inclusive(i - d, i + d).map(Math.floorMod(_, s.size)).map(s)
  def apply(s: Seq[Seq[S]]) = s.indices.map(x => s(x).indices.map(y => rule(ROI(x)(s).map(ROI(y)))))
}
```

ruleが遷移規則で、applyが状態遷移を表す。ROIが隣接セルである。具体的な遷移規則は、CA2型を継承して定義する。

```scala
object WireWorldRule extends CA2[Char](ROI => ROI(1)(1) match {
  case 'W' if(ROI.flatten.count(_ == 'H') == 1) => 'H'
  case 'W' if(ROI.flatten.count(_ == 'H') == 2) => 'H'
  case 'W' => 'W'
  case 'H' => 'T'
  case 'T' => 'W'
  case 'B' => 'B'
})
```

以下は**ライフゲーム**の定義である。生命の進化や淘汰を思わせる複雑な模様を描き、やはり任意の計算機を模倣できる。

```scala
object LifeGameRule extends CA2[Char](ROI => ROI(1)(1) match {
  case 'L' if(ROI.flatten.count(_ == 'L') == 3) => 'L'
  case 'L' if(ROI.flatten.count(_ == 'L') == 4) => 'L'
  case 'D' if(ROI.flatten.count(_ == 'L') == 3) => 'L'
  case  _  => 'D'
})
```

### 3.2 チューリング機械

**チューリング機械**は、無限長の**テープ**と、その内容を読み書きする有限状態機械と、式 3.2の遷移関数 $\delta$ で構成される。
状態 $q_n$ で記号 $x_n$ を読み取ると、記号 $y_n$ に書き換える。状態 $q_{n+1}$ に遷移して $\lambda_n$ の方向に移動し、再び記号を読み取る。

$$(q_{n+1},y_n,\lambda_n) = \delta(q_n,x_n),
\enspace\mathrm{where}\enspace
\left\lbrace 
\begin{aligned}
q_n &\in Q,\\
x_n,y_n &\in \Sigma,\\
\lambda_n &\in \lbrace L,R\rbrace .
\end{aligned}
\right. \qquad(3.2)$$

逐次処理型の計算機と理論的に等価であり、実行可能な計算は、並列処理型の万能機械であるセルオートマトンに並ぶ。
特に、**帰納的に枚挙可能**な集合の計算が得意である。2進数で与えられた自然数の後続を求める手順を、Fig. 3.2に示す。

![images/tape.plus1.png](/images/tape.plus1.png)

(1) 100=011+001.
 
![images/tape.plus2.png](/images/tape.plus2.png)

(2) 110=101+001.
 
![images/tape.plus3.png](/images/tape.plus3.png)

(3) 111=110+001.

Fig. 3.2 numerical increment operation on a Turing machine ( $k=1$ ).

任意の遷移関数を読み取り、その遷移関数を忠実に実行する、言語処理系と等価な**万能チューリング機械**も実装できる。
遷移関数と計算手順で、異なるテープを使用した例をUTM型に実装する。状態0から1にかけて、遷移規則を検索する。

```scala
class UTM[V](data1: Seq[V], data2: Seq[V], b1: V, b2: V, mL: V, mR: V, var s1: V, var s2: Int = 0) {
  val tape1 = data1.zipWithIndex.map(_.swap).to(collection.mutable.SortedMap)
  val tape2 = data2.zipWithIndex.map(_.swap).to(collection.mutable.SortedMap)
  var hd1 = 0
  var hd2 = 0
  def r1 = tape1.getOrElse(hd1, b1)
  def r2 = tape2.getOrElse(hd2, b2)
  def apply(sop: V) = Iterator.continually(s2 match {
    case 0 if r2 == s1 => (s1 = s1, s2 = 1, tape1(hd1) = r1, hd1 += 0, hd2 += 1)
    case 0 if r2 != s1 => (s1 = s1, s2 = 0, tape1(hd1) = r1, hd1 += 0, hd2 += 5)
    case 1 if r2 == r1 => (s1 = s1, s2 = 2, tape1(hd1) = r1, hd1 += 0, hd2 += 1)
    case 1 if r2 != r1 => (s1 = s1, s2 = 0, tape1(hd1) = r1, hd1 += 0, hd2 += 4)
    case 2 if r2 != b2 => (s1 = r2, s2 = 3, tape1(hd1) = r1, hd1 += 0, hd2 += 1)
    case 3 if r2 != b2 => (s1 = s1, s2 = 4, tape1(hd1) = r2, hd1 += 0, hd2 += 1)
    case 4 if r2 == b1 => (s1 = s1, s2 = 5, tape1(hd1) = r1, hd1 += 0, hd2 += 1)
    case 4 if r2 == mL => (s1 = s1, s2 = 5, tape1(hd1) = r1, hd1 -= 1, hd2 += 1)
    case 4 if r2 == mR => (s1 = s1, s2 = 5, tape1(hd1) = r1, hd1 += 1, hd2 += 1)
    case 5 if r2 == b2 => (s1 = s1, s2 = 0, tape1(hd1) = r1, hd1 += 0, hd2 += 1)
    case 5 if r2 != b2 => (s1 = s1, s2 = 5, tape1(hd1) = r1, hd1 += 0, hd2 -= 1)
  }).takeWhile(t => s1 != sop || s2 != 0).map(t => tape1.values.mkString)
}
```

状態2から4にかけて、状態遷移と書き戻しと移動を行う。状態5でテープの左端に戻り、状態0に戻る。使用例を示す。
遷移規則は式 3.2の通り、5個組で読み込ませる。初期状態Iから状態Fまで動かすと、Fig. 3.2の計算が実行される。

```scala
case class CUTM(data1: String, data2: String) extends UTM(data1, data2, ' ', '*', 'L', 'R', 'I')
CUTM("0111111", "I0a0RI1a1Ra0a0Ra1a1Ra b Lb0c1Lb1b0Lb F1 c0c0Lc1c1Lc F R")('F').foreach(println)
```

